{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Background","text":""},{"location":"#helpful-tutorial-links","title":"Helpful tutorial links","text":"<ul> <li>https://snakemake.readthedocs.io/en/stable/tutorial/basics.html</li> <li>https://snakemake.readthedocs.io/en/stable/tutorial/advanced.html</li> <li>https://carpentries-incubator.github.io/workflows-snakemake/</li> </ul>"},{"location":"usage/example/","title":"Dry Run Expected Output","text":"<ul> <li> <p>The output of the dry-run for Rule A should look as follows: <pre><code>job      count    min threads    max threads\n-----  -------  -------------  -------------\nA            2              1              1\nall          1              1              1\ntotal        3              1              1\n</code></pre></p> </li> <li> <p>The output of the dry-run for Rules A-B should look as follows: <pre><code>job      count    min threads    max threads\n-----  -------  -------------  -------------\nA            2              1              1\nB            2              1              1\nall          1              1              1\ntotal        5              1              1\n</code></pre></p> </li> <li> <p>The output of the dry-run for Rules A-C should look as follows: <pre><code>job      count    min threads    max threads\n-----  -------  -------------  -------------\nA            2              1              1\nB            2              1              1\nC            1              1              1\nall          1              1              1\ntotal        6              1              1\n</code></pre></p> </li> <li> <p>The output of the dry-run for Rules A-D should look as follows: <pre><code>job      count    min threads    max threads\n-----  -------  -------------  -------------\nA            2              1              1\nB            2              1              1\nC            1              1              1\nD            2              1              1\nall          1              1              1\ntotal        8              1              1\n</code></pre></p> </li> <li> <p>The output of the dry-run for Rules A-E should look as follows: <pre><code>job      count    min threads    max threads\n-----  -------  -------------  -------------\nA            2              1              1\nB            2              1              1\nC            1              1              1\nD            2              1              1\nE            2              1              1\nall          1              1              1\ntotal        10             1              1\n</code></pre></p> </li> </ul>"},{"location":"usage/example/#expected-output-files-structure","title":"Expected Output Files / Structure","text":"<ul> <li> <p>The output of Rule A: <pre><code>\u251c\u2500\u2500 sample_1_rulea.txt\n\u251c\u2500\u2500 sample_2_rulea.txt\n</code></pre></p> </li> <li> <p>The output of Rule B: <pre><code>\u251c\u2500\u2500 sample_1_rulea.txt\n\u251c\u2500\u2500 sample_1_ruleb.txt\n\u251c\u2500\u2500 sample_2_rulea.txt\n\u251c\u2500\u2500 sample_2_ruleb.txt\n</code></pre></p> </li> <li> <p>The output of Rule C: <pre><code>\u251c\u2500\u2500 final_output\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 merged_rulea.txt\n\u251c\u2500\u2500 sample_1_rulea.txt\n\u251c\u2500\u2500 sample_1_ruleb.txt\n\u251c\u2500\u2500 sample_2_rulea.txt\n\u2514\u2500\u2500 sample_2_ruleb.txt\n</code></pre></p> </li> <li> <p>The output of Rule D: <pre><code>\u251c\u2500\u2500 final_output\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 merged_rulea.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sample_1_copied_ruleb.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 sample_2_copied_ruleb.txt\n\u251c\u2500\u2500 sample_1_rulea.txt\n\u251c\u2500\u2500 sample_1_ruleb.txt\n\u251c\u2500\u2500 sample_2_rulea.txt\n\u2514\u2500\u2500 sample_2_ruleb.txt\n</code></pre></p> </li> <li> <p>The output of advanced tasks: <pre><code>final_output/\n\u251c\u2500\u2500 merged_rulea.txt\n\u251c\u2500\u2500 sample_1_copied_ruleb.txt\n\u2514\u2500\u2500 sample_2_copied_ruleb.txt\n</code></pre></p> </li> <li> <p>The output of Rule E: <pre><code>final_output/\n\u251c\u2500\u2500 merged_rulea.txt\n\u251c\u2500\u2500 sample_1_copied_ruleb.txt\n\u251c\u2500\u2500 sample_1.sam\n\u251c\u2500\u2500 sample_2_copied_ruleb.txt\n\u2514\u2500\u2500 sample_2.sam\n</code></pre></p> </li> </ul>"},{"location":"usage/example/#explanations","title":"Explanations","text":""},{"location":"usage/example/#general-notes","title":"General Notes","text":"<ul> <li>The <code>join</code> and <code>expand</code> functions<ul> <li>the join function is used to create and manage path structure by converting all \",\" to </li> <li>the expand expands each variable defined, iterating through combinations</li> <li>for example (expand(join(out_dir,'{sp}_rulea.txt'),sp=sp_list)) expands to the following:<ul> <li>expand(/path/to/out_dir/{sp}_rulea.txt)</li> </ul> </li> <li>the sp_list is defined as ('sample_1' and 'sample_2'), the command expands further to:<ul> <li>(/path/to/out_dir/sample_1_rulea.txt,/out/dir/sample_2_rulea.txt)</li> </ul> </li> </ul> </li> </ul>"},{"location":"usage/example/#rule-a","title":"Rule A","text":"<ul> <li>Rule A requires that wildcards <code>{sp}</code> used in both the input and output. This wildcard is defined in the rule all, by setting the output of rule A with definition as <code>sp=sp_list</code>. <pre><code># ruleA output\nexpand(join(out_dir,'{sp}_rulea.txt'),sp=sp_list),\n</code></pre></li> <li>An example of this rule's execution follows: <pre><code>rule A:\n    input:\n        fq = join(data_dir,'{sp}.fq')\n    output:\n        final = join(out_dir,'{sp}_rulea.txt')\n    shell:\n        '''\n        cat {input.fq} &gt; {output.final}\n        echo \"\\nruleA completed\" &gt;&gt; {output.final}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/example/#rule-b","title":"Rule B","text":"<ul> <li>Rule B requires a function to be used in order to generate the required input. The function uses the <code>wildcards</code> feature to pull the information from the output <code>{sp}</code>. Again, this wildcard is defined in the rule all, by setting the output of rule B with <code>sp=sp_list</code>.</li> <li>An example of this def and the rule's execution follows: <pre><code>def get_input_files(wildcards):\n    #example: {data_dir}/{sample_id.fq}\n    fq = join(data_dir,fastq_dict[wildcards.sp])\n    return(fq)\n\nrule B:\n    input:\n        fq = get_input_files    \n    output:\n        final = join(out_dir,'{sp}_ruleb.txt')\n    shell:\n        '''\n        cat {input.fq} &gt; {output.final}\n        echo \"\\nruleB completed\" &gt;&gt; {output.final}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/example/#rule-c","title":"Rule C","text":"<ul> <li>Rule C requires a function to perform a command, which is directed through <code>params: cmd</code>. In this example the command is a simple copy, where the output has changed names.</li> <li>An example of this def and the rule's execution follows: <pre><code>def get_rulec_cmd(wildcards):\n    cmd='cat '\n    sp_paths=''\n    for sp in sp_list:\n        # set source (ruleB) and destination files\n        source = join(out_dir, sp + '_rulea.txt')\n\n        # create command\n        sp_paths = source + ' ' + sp_paths\n\n    # add output path    \n    destination = join(out_dir, 'final_output','merged_rulea.txt')\n    cmd = cmd + sp_paths + ' &gt;&gt; ' + destination\n\n    return(cmd)\n\nrule C:\n    input:\n        rulea = expand(join(out_dir,'{sp}_rulea.txt'),sp=sp_list)\n    params:\n        cmd = get_rulec_cmd\n    output:\n        final = join(out_dir,'final_output','merged_rulea.txt')\n    shell:\n        '''\n        # create the final output file\n        touch {output.final}\n\n        # run the cat command\n        {params.cmd}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/example/#rule-d","title":"Rule D","text":"<ul> <li>Rule D required that the input of the rule be the linked to Rule B. This is accomplished using the <code>rules.output</code> format. Since individual files are included through the iteration of <code>sp</code> in the rules all. If the output file was a single file, all output files of rule B would be given as a single list.</li> <li>An example of this def and the rule's execution follows: <pre><code>def get_ruled_cmd(wildcards):\n    cmd=''\n    for sp in sp_list:\n        # set source (ruleB) and destination files\n        source = join(out_dir, wildcards.sp + '_ruleb.txt')\n        destination = join(out_dir, 'final_output', wildcards.sp + '_copied_ruleb.txt')\n\n        # cp the the files\n        cmd = 'cp ' + source + ' ' + destination + '; ' + cmd\n\n    return(cmd)\n\nrule D:\n    input:\n        ruleb = rules.B.output.final\n    params:\n        cmd = get_ruled_cmd\n    output:\n        final = join(out_dir, 'final_output', '{sp}_copied_ruleb.txt')\n    shell:\n        '''\n        # run the command\n        {params.cmd}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/example/#temp-files","title":"Temp files","text":"<ul> <li>To designate a <code>temp</code> file, simply include <code>temp</code> prior to the file name in output, as shown below: <pre><code>rule B:\n    input:\n        fq = get_input_files\n    params:\n        rname='rule_B',\n    output:\n        final = temp(join(out_dir,'{sp}_ruleb.txt'))\n    shell:\n        '''\n        cat {input.fq} &gt; {output.final}\n        echo \"\\nruleB completed\" &gt;&gt; {output.final}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/example/#link-rule-name-to-log-files","title":"Link rule name to log files","text":"<ul> <li>This must be done in two steps. First, each rule must include a param with the <code>rname</code> variable, as shown below: <pre><code>rule B:\n    input:\n        fq = get_input_files\n    params:\n        rname='rule_B',\n    output:\n        final = temp(join(out_dir,'{sp}_ruleb.txt'))\n    shell:\n        '''\n        cat {input.fq} &gt; {output.final}\n        echo \"\\nruleB completed\" &gt;&gt; {output.final}\n        '''\n</code></pre></li> <li>Then, the param variable can be used in the submission of the sbatch file. For example <code>{params.rname}</code> is used below: <pre><code>\"sbatch --gres {cluster.gres} --cpus-per-task {cluster.threads} \\\n    -p {cluster.partition} -t {cluster.time} --mem {cluster.mem} --job-name={params.rname} \\\n    --output=${output_dir}/log/{params.rname}{cluster.output} \\\n    --error=${output_dir}/log/{params.rname}{cluster.error}\"\n</code></pre></li> </ul>"},{"location":"usage/example/#initalization","title":"Initalization","text":"<ul> <li>Initialization features ensure that the pipeline configuration files and documentation is stored with the pipeline. This includes creating output dirs, not included in snakemake and copiying configuration files that are utilized within the pipeline. Finally, sed commands can be used to replace variables with either command_line inputs or current_directory inputs, as shown below: <pre><code># create directories if they do not exist\nif [[ ! -d $output_dir ]]; then mkdir $output_dir; fi\ndir_list=(config log)\nfor pd in \"${dir_list[@]}\"; do if [[ ! -d $output_dir/$pd ]]; then mkdir -p $output_dir/$pd; fi; done\n\n# saving files, updating the configs with correct paths\nfiles_save=('config/snakemake_config.yaml' 'workflow/Snakefile' 'config/cluster_config.yaml')\nfor f in ${files_save[@]}; do\n    # set absolute path of file\n    f=\"${PIPELINE_HOME}/$f\"\n\n    # create an array of the absolute path, with the delimiter of \"/\"\n    IFS='/' read -r -a strarr &lt;&lt;&lt; \"$f\" \n\n    # replace the variables PIPELINE_HOME and OUTPUT_dir in any files within the files_save array ($f)\n    # save this output to the file name (strarr[-1]) in the output_dir/config location\n    sed -e \"s/PIPELINE_HOME/${PIPELINE_HOME//\\//\\\\/}/g\" -e \"s/OUTPUT_DIR/${output_dir//\\//\\\\/}/g\" $f &gt; \"${output_dir}/config/${strarr[-1]}\"\n\ndone\n</code></pre></li> </ul>"},{"location":"usage/example/#cluster-notes","title":"Cluster notes","text":"<ul> <li> <p>Update the <code>cluster_config.yaml</code> for a specific rule by adding that rule name, and including the parameter to change. For example, to change the time limit from <code>2</code> hours to <code>1</code> hour and threads from <code>4</code> to <code>2</code> for Rule E: <pre><code>E:\n  time: 00-01:00:00\n  threads: 2\n</code></pre></p> </li> <li> <p>An example of the full cluster command needed to excute the pipeline is as follow: <pre><code>    sbatch --job-name=\"snakemake_tutorial\" \\\n    --gres=lscratch:200 \\\n    --time=120:00:00 \\\n    --output=${output_dir}/log/%j_%x.out \\\n    --mail-type=BEGIN,END,FAIL \\\n    snakemake -s $output_dir/config/Snakefile \\\n    --configfile $output_dir/config/snakemake_config.yaml \\\n    --printshellcmds \\\n    --verbose \\\n    --rerun-incomplete \\\n    --latency-wait 120 \\\n    --use-envmodules \\\n    --cores 1 \\\n    --cluster-config ${output_dir}/config/cluster_config.yaml \\\n    -j 5 \\\n    --cluster \\\n    \"sbatch --gres {cluster.gres} --cpus-per-task {cluster.threads} \\\n    -p {cluster.partition} -t {cluster.time} --mem {cluster.mem} --job-name={params.rname} \\\n    --output=${output_dir}/log/{params.rname}{cluster.output} \\\n    --error=${output_dir}/log/{params.rname}{cluster.error}\"\n</code></pre></p> </li> <li>The breakdown of this is to create an sbatch job which acts as the <code>master</code> job, and controls all subsequent jobs. This master job submits the <code>snakemake</code> command, with all accompanying Snakefile and config files. Finally, the <code>cluster</code> command submits the criterion for all rule-related sbatch jobs that will be used as the pipeline runs</li> </ul>"},{"location":"usage/example/#rule-e","title":"Rule E","text":"<ul> <li>Rule E required the addition of <code>envmodules</code> which reads from the added config parameter <code>samtools</code>, as well as the <code>threads</code> option. </li> <li>An example of this rule's execution follows: <pre><code>rule E:\n    input:\n        bamfile = join(data_dir,'{sp}.bam')\n    envmodules:\n        config['samtools']\n    params:\n        rname='rule_E',\n    threads: getthreads(\"E\")\n    output:\n        final = join(out_dir, 'final_output', '{sp}.sam')\n    shell:\n        '''\n        samtools view -H -@ {threads} {input.bamfile} &gt; {output.final}\n        '''\n</code></pre></li> </ul>"},{"location":"usage/getting-started/","title":"1. Getting Started","text":""},{"location":"usage/getting-started/#prepare-the-environment","title":"Prepare the environment","text":"<p>Connect to Biowulf and load an interactive session <pre><code># login\nssh -Y $USER@biowulf.nih.gov\n\n# load interactive session\nsrun -N 1 -n 1 --time=12:00:00 -p interactive --mem=8gb  --cpus-per-task=4 --pty bash\n</code></pre></p>"},{"location":"usage/getting-started/#clone-the-repo","title":"Clone the Repo","text":"<p>Clone the github repo <pre><code>cd /path/to/working/dir\n\ngit clone https://github.com/slsevilla/snakemake_tutorial.git\n\ncd snakemake_tutorial\n</code></pre></p>"},{"location":"usage/getting-started/#completing-the-activty","title":"Completing the Activty","text":"<p>Two diretories were created within the repo. The <code>pipeline_todo</code> directory should be used to complete the tutorial, editing all files as needed. The <code>pipeline_example</code> directory has the activity completed and should be used a reference for completing each of the tasks.</p> <p>NOTE: There are multiple ways to complete each rule, so review the expected outputs within the <code>pipeline_example/output</code> directory if your code varies.</p>"},{"location":"usage/task/","title":"Overview","text":"<p>Learn some of the basics of Snakemake through the following tutorial.</p> <ol> <li>Create a script to run Snakemake</li> <li>Create variables to run a snakemake_config file</li> <li>Create rules for scenarios</li> <li>Use script to invoke Snakemake</li> </ol>"},{"location":"usage/task/#manifest-files","title":"Manifest Files","text":"<p>Manifest files have already been created in the <code>/snakemake_tutorial/manifest</code> directory. This includes:</p> <p>sample_manifest.csv <pre><code>sample_id,fq_name,bam_name\nsample_1,sample_1.fq,sample_1.bam\nsample_2,sample_2.fq,sample_2.bam\n</code></pre></p>"},{"location":"usage/task/#activity","title":"Activity","text":"<p>The task can be broken up into A. pre-processing, B. sample handling, C. rule creation, and D. Advanced Commands. All edits should be completed in the <code>/snakemake_tutorial/pipeline_todo/</code> directory.</p>"},{"location":"usage/task/#a-pre-processing","title":"A. Pre-Processing","text":"<ul> <li>Create the <code>output_dir</code>, and a subdirectory <code>log</code></li> <li>Create two different Snakemake commands, one for a dry run and one for a local run to the <code>run_snakemake.sh</code>. The commands should be <code>dry</code> or <code>local</code>.<ul> <li>Include the path to the workflow/Snakefile, the config/snakemake_config.yaml in both commands</li> <li>Include flags --printshellcmds, --verbose, --rerun-incomplete in both commands</li> <li>Include flag --cores 1 for the <code>local</code> command</li> </ul> </li> </ul>"},{"location":"usage/task/#b-sample-handling","title":"B. Sample Handling","text":"<ul> <li>Create the parameters in the <code>config/snakemake_config.yaml</code> <pre><code>'sampleManifest' which gives the path of the sampleManifest\n\n'out_dir' which gives the path to the output dir (must exist)\n\n'data_dir' which gives the path to the data dir found under \"/snakemake_tutorial/data/\"\n</code></pre></li> <li>Create the sample dictionaries and project lists from the manifest in the <code>workflow/Snakefile</code> <pre><code>`CreateSampleDicts` creates a dictionary matching sample_id to fq_file and a dictionary which matches sample_id to bam_file\n\n`CreateProjLists` creates a project lists `sp_list` which contains all sample_ids, `fq_list` which contains all fq_file names, and `bam_list` which contains all bam_file names\n</code></pre></li> </ul>"},{"location":"usage/task/#c-basic-activities","title":"C. Basic activities","text":"<p>Complete each of the following tasks, in order. Be sure to perform dry runs and complete runs between each rule creation. The Hints section below provides guidance on each rule, while the Example page provides a detailed explanation of rule creation and features.</p> <ul> <li>General Tasks<ul> <li>Create rule_all for each rule one at a time in the <code>workflow/Snakefile</code>.</li> <li>Create rule_all input for all fq input files, from the <code>fq_list</code></li> </ul> </li> <li>Rule A<ul> <li>input files should be <code>{sample_id}.fq</code></li> <li>output should be <code>{sample_id}_rulea.txt</code> and should be output to the <code>out_dir</code></li> <li>shell command should add a line \"ruleA completed on a new line\" to the original file</li> </ul> </li> <li>Rule B<ul> <li>input files should be <code>get_input_files</code>. this definition will look up the name of the fq by taking in the <code>sample_id</code> as a wildcard, and using the <code>samp_dict</code></li> <li>output should be <code>{sample_id}_ruleb.txt</code> and should be output to the <code>out_dir</code></li> <li>shell command should add a line \"ruleB completed on a new line\" to the original file</li> </ul> </li> <li>Rule C<ul> <li>input files should be all of Rule A's output files</li> <li>params should be def <code>get_rulec_cmd</code> which iterates through all samples and creates a command <code>cat {sample1}_rulea.txt {sample2}_rulea.txt &gt;&gt; {final_file}</code> </li> <li>output should be <code>merged_rulea.txt</code> and should be output to the <code>out_dir/final_output</code></li> <li>shell command should touch the <code>{final_file}</code>, then run the <code>cmd</code> parameter</li> </ul> </li> <li>Rule D<ul> <li>input files should be directly linked to Rule B's output files</li> <li>params should be def <code>get_ruled_cmd</code> which iterates through all samples and creates a command <code>cp /output/path/{sample_id}_ruleb.txt /output/path/final_output/{sample_id)_copies_ruleb.txt;</code> for each sample</li> <li>output should be <code>{sample_id}_copied_ruleb.txt</code> and should be output to the <code>out_dir/final_output</code></li> <li>shell command should run the <code>cmd</code> parameter</li> </ul> </li> </ul>"},{"location":"usage/task/#d-advanced-activities","title":"D. Advanced activities","text":"<ul> <li>Add features to the <code>workflow/Snakefile</code>:<ul> <li>Designate temp files<ul> <li>flag rule A and rule B files so they are deleted after the pipeline completion</li> </ul> </li> <li>Link rule names to log files<ul> <li>all rules must have a param called <code>rname</code> where the rule name is identified uniquely</li> </ul> </li> </ul> </li> <li>Add initializtion features to the pipeline<ul> <li>Add features to the <code>run_snakemake.sh</code> file to include:<ul> <li>check if output_dir or output_dir/log are created; if not create them during invocation of the <code>run_snakemake.sh</code> file</li> <li>copy the config/snakemake_config.yaml, config/cluster_config.yaml to the output_dir; ensure snakemake runs use these files</li> <li>update all config files with the <code>output_dir</code> variable given from the command line and <code>pipeline_dir</code> variable based on the invocation location of the pipeline;</li> </ul> </li> </ul> </li> <li>Utilize <code>cluster</code> for rules<ul> <li>Add features to the <code>run_snakemake.sh</code> file to include:<ul> <li>update the copies <code>cluster_config.yaml</code> to change the time limit from <code>2</code> hours to <code>1</code> hour and threads from <code>4</code> to <code>2</code> for Rule E</li> </ul> </li> <li>Add a new command to the <code>run_snakemake.sh</code> file:<ul> <li>name the new command <code>cluster</code>. This command will include all of the previous flags of <code>local</code>.</li> <li>expand the <code>cluster</code> command with<code>sbatch</code> additional flags: <ul> <li><code>--job-name=\"snakemake_tutorial\"</code></li> <li><code>--gres=lscratch:200</code></li> <li><code>--time=120:00:00</code></li> <li><code>--output=${output_dir}/log/%j_%x.out</code></li> <li><code>--mail-type=BEGIN,END,FAIL</code></li> </ul> </li> <li>expand the <code>cluster</code> command further, with additional snakemake flags:<ul> <li><code>--latency-wait 120</code></li> <li><code>--use-envmodules</code></li> <li><code>-j 5</code></li> <li><code>--cluster-config ${output_dir}/config/cluster_config.yml</code></li> </ul> </li> <li>expand the <code>cluster</code> command further, with additional snakemake cluster flags:<ul> <li><code>cluster \"sbatch --gres {cluster.gres} --cpus-per-task {cluster.threads} -p {cluster.partition} -t {cluster.time} --mem {cluster.mem} --job-name={params.rname} --output=${output_dir}/log/{params.rname}{cluster.output} --error=${output_dir}/log/{params.rname}{cluster.error}\"</code></li> </ul> </li> </ul> </li> </ul> </li> <li>Rule E<ul> <li>General Tasks<ul> <li>Create rule_all input for all bam input files, from the <code>bam_list</code></li> </ul> </li> <li>input files should be <code>{sample_id}.fq</code></li> <li>envmodules should load the samtools version <code>samtools/1.15.1</code> from the <code>snakemake_config.yaml</code> file</li> <li>threads should use def <code>getthreads</code></li> <li>params should have <code>rname</code> set as a unique rule name</li> <li>output should be <code>{sample_id}.sam</code> and should be output to the <code>out_dir/final_output</code></li> <li>shell command should use samtools to output the header to a sam file</li> </ul> </li> </ul>"},{"location":"usage/task/#hints","title":"Hints","text":"<ul> <li>Rule A and rule B are using the same input files, but only differ in how these files are being referenced. There are times when the sample_id of an input file will match, but other times (as when taking in a multiplexed ID when they will not be the same). Rule A handles cases where they match, rule B handles cases where they would not match.</li> <li>Rule B invokes a function to define the input files. Read more about this here.</li> <li>Rule C uses the expand feature for to gather all required input files. Read more about this here.</li> <li>Rule C and Rule D are outputting data to a directory that does not exist (<code>out_dir/final_output</code>). Snakemake will automatically create directories that don't exist, when they are listed as <code>output</code> files.</li> <li>Rule C should use the def definted to iterate through all the samples created in the sp_list.</li> <li>Rule D requires a \"link\" to Rule B's outptu through the use of the <code>rules.RuleName.output.OutputName</code>. Read more about this here.</li> <li>Advanced commands require use of the <code>temp</code> feature of snakemake. Read more about this here.</li> <li>Advanced commands require the use of the <code>cluster</code> feature of snakemake. Read more about this here.</li> <li>Cluster config file will follow the variable format from Biowulf for all sbatch parameters</li> <li>Rule E requires outputting the header <code>samtools view -H</code> of a file</li> </ul>"}]}